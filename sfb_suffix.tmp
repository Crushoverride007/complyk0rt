          },
          {
            number: 4,
            heading: 'Details about Reviewed Environment',
            items: [
              { id: '4.1', number: '4.1', label: 'System components', fields: [ { id:'components', type:'textarea', label:'System components' } ] },
              { id: '4.2', number: '4.2', label: 'In-scope applications', fields: [ { id:'apps', type:'textarea', label:'In-scope applications' } ] },
              { id: '4.3', number: '4.3', label: 'Payment channels', fields: [ { id:'paymentChannels', type:'textarea', label:'Payment channels' } ] },
              { id: '4.4', number: '4.4', label: 'Third-party service providers', fields: [ { id:'tpsps', type:'textarea', label:'Third-party service providers' } ] },
            ],
          },
          {
            number: 5,
            heading: 'Quarterly Scan Results',
            items: [
              { id: '5.1', number: '5.1', label: 'Q1' },
              { id: '5.2', number: '5.2', label: 'Q2' },
              { id: '5.3', number: '5.3', label: 'Q3' },
              { id: '5.4', number: '5.4', label: 'Q4' },
            ],
          },
        ],
      },
      {
        title: 'Part II: Sampling and Evidence, Findings and Observations',
        sections: [
          {
            number: 6,
            heading: 'Sampling and Evidence',
            items: [
              { id: '6.1', number: '6.1', label: 'Sampling approach' },
              { id: '6.2', number: '6.2', label: 'Evidence collected' },
              { id: '6.3', number: '6.3', label: 'Sampled entities' },
              { id: '6.4', number: '6.4', label: 'Deviations' },
            ],
          },
          {
            number: 7,
            heading: 'Findings and Observations',
            items: [
              { id: '7.1', number: '7.1', label: 'Build and Maintain a Secure Network and Systems' },
              { id: '7.2', number: '7.2', label: 'Protect Account Data' },
              { id: '7.3', number: '7.3', label: 'Maintain a Vulnerability Management Program' },
              { id: '7.4', number: '7.4', label: 'Implement Strong Access Control Measures' },
              { id: '7.5', number: '7.5', label: 'Regularly Monitor and Test Networks' },
              { id: '7.6', number: '7.6', label: 'Maintain an Information Security Policy' },
              { id: 'APP-A', number: null, label: 'Appendix A: Additional PCI DSS Requirements' },
              { id: 'APP-B', number: null, label: 'Appendix B: Compensating Controls' },
              { id: 'APP-C', number: null, label: 'Appendix C: Compensating Controls Worksheet' },
              { id: 'APP-D', number: null, label: 'Appendix D: Customized Approach' },
              { id: 'APP-E', number: null, label: 'Appendix E: Customized Approach Template' },
            ],
          },
        ],
      },
    ],
  },
  'PCI DSS 3.2.1': {
    code: 'pci-dss-3-2-1',
    parts: [
      {
        title: 'Part I: Assessment Overview',
        sections: [
          { number: 1, heading: 'Contact Information and Report', items: [
            { id:'1.1', number:'1.1', label:'Contact Information' },
            { id:'1.2', number:'1.2', label:'Date and timeframe of' },
            { id:'1.3', number:'1.3', label:'PCI DSS version' },
            { id:'1.4', number:'1.4', label:'Additional services provided' },
            { id:'1.5', number:'1.5', label:'Summary of Findings' },
          ]},
          { number: 2, heading: 'Summary Overview', items: [
            { id:'2.1', number:'2.1', label:"Description of the entity's" },
            { id:'2.2', number:'2.2', label:'High-level network diagram' },
          ]},
        ],
      },
    ],
  },
};



// Load persisted data if available
const persisted = loadData();
if (persisted) {
  if (persisted.sectionAttachmentsByAssessment) Object.assign(sectionAttachmentsByAssessment, persisted.sectionAttachmentsByAssessment);
  if (Array.isArray(persisted.assessments)) { assessments.length = 0; persisted.assessments.forEach(a=>assessments.push(a)); }
  if (Array.isArray(persisted.users)) { users.length = 0; persisted.users.forEach(u=>users.push(u)); }
  if (persisted.tasksByAssessment) Object.assign(tasksByAssessment, persisted.tasksByAssessment);
  if (persisted.messagesByAssessment) Object.assign(messagesByAssessment, persisted.messagesByAssessment);
  if (persisted.attachmentsByAssessment) Object.assign(attachmentsByAssessment, persisted.attachmentsByAssessment);
  if (persisted.answersByAssessment) Object.assign(answersByAssessment, persisted.answersByAssessment);
}
// CORS & JSON
app.use((req, res, next) => {
  // Dev-only: set a safe Permissions-Policy that avoids 'browsing-topics' warnings
  res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  next();
});
app.use(cors({ origin: '*', methods: ['GET','POST','PUT','DELETE','OPTIONS'], allowedHeaders: ['Content-Type','Authorization'] }));
app.use(express.json());

function snapshot() {
  return { assessments, tasksByAssessment, messagesByAssessment, attachmentsByAssessment, answersByAssessment, sectionAttachmentsByAssessment };
}

// Periodic save
setInterval(()=> saveData(snapshot()), 10000);

// Health
app.get('/health', (req,res)=> res.json({ status:'OK', message:'Backend running!' }));

// Auth
app.post('/login', (req, res) => {
  const { email, password } = req.body || {};
  const isValid = (
    (email === 'admin@acme.example.com' && password === 'demo123!') ||
    (email === 'manager@acme.example.com' && password === 'demo123!')
  );
  if (!isValid) return res.status(401).json({ success:false, message:'Invalid credentials' });
  const found = users.find(u => u.email === email);
  const token = 'demo_token_' + Math.random().toString(36).slice(2);
  tokenToEmail.set(token, email);
  res.json({ success:true, token, user: found });
});

app.get('/me', (req, res) => {
  const auth = req.headers.authorization || '';
  const token = auth.startsWith('Bearer ') ? auth.slice(7) : null;
  if (!token || !tokenToEmail.has(token)) return res.status(401).json({ success:false, message:'Unauthorized' });
  const email = tokenToEmail.get(token);
  const user = users.find(u => u.email === email);
  if (!user) return res.status(404).json({ success:false, message:'User not found' });
  res.json({ success:true, user });
});


// --- Compatibility aliases for frontend client ---
// Auth login: returns { success, data: { user, token } }
app.post('/api/auth/login', (req, res) => {
  const { email, password } = req.body || {};
  const isValid = (
    (email === 'admin@acme.example.com' && password === 'demo123!') ||
    (email === 'manager@acme.example.com' && password === 'demo123!')
  );
  if (!isValid) return res.status(401).json({ success:false, message:'Invalid credentials' });
  const found = users.find(u => u.email === email);
  const token = 'demo_token_' + Math.random().toString(36).slice(2);
  tokenToEmail.set(token, email);
  res.json({ success:true, data: { user: found, token } });
});

// Auth me: returns { success, data: user }
app.get('/api/auth/me', (req, res) => {
  const auth = req.headers.authorization || '';
  const token = auth.startsWith('Bearer ') ? auth.slice(7) : null;
  if (!token || !tokenToEmail.has(token)) return res.status(401).json({ success:false, message:'Unauthorized' });
  const email = tokenToEmail.get(token);
  const user = users.find(u => u.email === email);
  if (!user) return res.status(404).json({ success:false, message:'User not found' });
  res.json({ success:true, data: user });
});

// Dev stub: roles endpoint to avoid 404s in dev
app.get('/api/me/roles', (req, res) => {
  res.json({ success: true, rolesByOrg: [] });
});


// Users aliases
app.get('/api/users', (req,res)=> res.json({ success:true, data: users }));
app.post('/api/users', (req,res)=>{
  const { email, name, role='member' } = req.body || {};
  if (!email || !name) return res.status(400).json({ success:false, message:'email and name required' });
  if (users.some(u=>u.email===email)) return res.status(409).json({ success:false, message:'email exists' });
  const id = String(users.length ? Math.max(...users.map(u=>Number(u.id||0)||0))+1 : 1);
  const user = { id, email, name, role, active:true };
  users.push(user);
  res.status(201).json({ success:true, data: user });
});
app.put('/api/users/:id', (req,res)=>{
  const { id } = req.params; const idx = users.findIndex(u=>String(u.id)===String(id));
  if (idx===-1) return res.status(404).json({ success:false, message:'not found' });
  const { name, role, active } = req.body || {};
  users[idx] = { ...users[idx], ...(name!==undefined?{name}:{}), ...(role!==undefined?{role}:{}), ...(active!==undefined?{active}:{}) };
  res.json({ success:true, data: users[idx] });
});
app.delete('/api/users/:id', (req,res)=>{
  const idx = users.findIndex(u=>String(u.id)===String(req.params.id));
  if (idx===-1) return res.status(404).json({ success:false, message:'not found' });
  users[idx].active = false; res.json({ success:true, data: users[idx] });
});


// Dashboard overview alias
app.get('/api/dashboard/overview', (req,res)=>{
  const payload = {
    user: users[0],
    stats: {
      totalControls: 100,
      completedControls: 85,
      pendingEvidences: 15,
      upcomingAudits: 2,
    },
    recentActivity: [
      { id: '1', description: 'SOX Control evidence uploaded', user: 'Admin User', timestamp: new Date().toISOString(), type:'evidence_uploaded' },
      { id: '2', description: 'Access Control policy updated', user: 'Manager User', timestamp: new Date().toISOString(), type:'control_updated' }
    ],
    controlsOverview: []
  };
  res.json({ success:true, data: payload });
});
// Dashboard sample
app.get('/dashboard', (req, res) => {
  res.json({
    user: users[0],
    stats: { totalControls: 100, completedControls: 85, pendingEvidences: 15, upcomingAudits: 2 },
    recentActivity: [
      { id: '1', type: 'evidence_uploaded', description: 'SOX Control evidence uploaded', timestamp: '2h ago', user: 'Admin User' },
      { id: '2', type: 'control_updated', description: 'Access Control policy updated', timestamp: '4h ago', user: 'Manager User' },
    ],
    controlsOverview: []
  });
});

// Users
app.get('/users', (req,res)=> res.json({ success:true, users }));
app.post('/users', (req,res)=>{
  const { email, name, role='member' } = req.body || {};
  if (!email || !name) return res.status(400).json({ success:false, message:'email and name required' });
  if (users.some(u=>u.email===email)) return res.status(409).json({ success:false, message:'email exists' });
  const id = String(users.length ? Math.max(...users.map(u=>Number(u.id)))+1 : 1);
  const user = { id, email, name, role, active:true };
  users.push(user);
  res.status(201).json({ success:true, user }); saveData(snapshot());
});
app.put('/users/:id', (req,res)=>{
  const { id } = req.params; const idx = users.findIndex(u=>u.id===id);
  if (idx===-1) return res.status(404).json({ success:false, message:'not found' });
  const { name, role, active } = req.body || {};
  users[idx] = { ...users[idx], ...(name!==undefined?{name}:{}), ...(role!==undefined?{role}:{}), ...(active!==undefined?{active}:{}) };
  res.json({ success:true, user: users[idx] }); saveData(snapshot());
});
app.delete('/users/:id', (req,res)=>{
  const idx = users.findIndex(u=>u.id===req.params.id);
  if (idx===-1) return res.status(404).json({ success:false, message:'not found' });
  users[idx].active = false; res.json({ success:true, user: users[idx] }); saveData(snapshot()); saveData(snapshot());
});

// Assessments
app.get('/assessments', (req,res)=> {
  const q = (req.query.archived||'').toString();
  let list = assessments;
  if (q === 'true') list = assessments.filter(a => !!a.archived);
  else if (q === 'all') list = assessments;
  else list = assessments.filter(a => !a.archived);
  // Ensure created and startDate fields exist for each assessment
  const nowIso = new Date().toISOString();
  list.forEach(a => { if (!a.created) a.created = nowIso; if (!a.startDate) a.startDate = a.created; });
  res.json({ success:true, assessments: list });
});
app.post('/assessments', (req,res)=>{
  const { title, col='backlog', dueIn='7 Days', framework='PCI DSS 3.2.1', created, startDate } = req.body || {};
  if (!title) return res.status(400).json({ success:false, message:'title required' });
  const maxNum = assessments.reduce((m,a)=>{
    const n = Number((a.id||'').split('-')[1]);
    return isNaN(n) ? m : Math.max(m, n);
  }, 0);
  const id = 'A-' + String(maxNum + 1).padStart(3,'0');
  const nowIso = new Date().toISOString();
  const a = { id, title, col, dueIn, framework, archived: false, created: created || nowIso, startDate: startDate || created || nowIso };
  assessments.push(a);
  tasksByAssessment[id] = [];
  messagesByAssessment[id] = [];
  attachmentsByAssessment[id] = [];
  res.status(201).json({ success:true, assessment:a }); saveData(snapshot());
});

// Framework-resolved structure for an assessment
app.get('/assessments/:id/structure', (req, res) => {
  const a = assessments.find(x => x.id === req.params.id);
  const fw = (a && (a.framework || 'PCI DSS 4.0')) || 'PCI DSS 4.0';
  const structure = frameworkStructures[fw] || { parts: [] };
  res.json({ success: true, framework: fw, structure });

});
// --- Export to DOCX using an existing template at /root/template ---
// Supports custom tags like {{r Contact('Client-Name')}} inside the .docx
// We duplicate the template and stream the filled version; the template file is never modified.
try {
  const fs = require('fs');
  const path = require('path');
  const PizZip = require('pizzip');
  const Docxtemplater = require('docxtemplater');

  function fmtDate(iso) {
    if (!iso) return '';
    try { return new Date(iso).toLocaleString('en-US', { year: 'numeric', month: 'short', day: '2-digit' }); } catch { return String(iso); }
  }

  // Custom parser to support tags like: r Contact('Client-Name')
  function customParser(tag) {
    const original = tag;
    const t = String(tag || '').trim();
    const m = t.match(/^r\s+([A-Za-z0-9_]+)\('([^']+)'\)\s*$/);
    if (m) {
      const group = m[1];
      const key = m[2];
      return {
        get: (scope) => {
          try {
            const g = scope[group] || {};
            const v = g[key];
            return (v == null ? '' : v);
          } catch { return ''; }
        }
      };

    }
    // Checkbox helper: cb Group('Key') -> â˜‘/â˜ or cb(path.to.value)
    const mcb1 = t.match(/^cb\s+([A-Za-z0-9_]+)\('([^']+)'\)\s*$/);
    if (mcb1) {
      const group = mcb1[1];
      const key = mcb1[2];
      const isTrue = (val) => {
        try {
          if (val === true) return true;
          if (typeof val === 'number') return val !== 0;
          if (typeof val === 'string') {
            const s = val.trim().toLowerCase();
            return ['true','yes','y','ok','1','checked','on'].includes(s);
          }
          return false;
        } catch { return false; }
      };
      return {
        get: (scope) => {
          try {
            const g = scope[group] || {};
            return isTrue(g[key]) ? 'â˜‘' : 'â˜';
          } catch { return 'â˜'; }
        }
      };
    }

    const mcb2 = t.match(/^cb\(([^)]+)\)\s*$/);
    if (mcb2) {
      const pathExpr = mcb2[1].trim();
      const isTrue = (val) => {
        try {
          if (val === true) return true;
          if (typeof val === 'number') return val !== 0;
          if (typeof val === 'string') {
            const s = val.trim().toLowerCase();
            return ['true','yes','y','ok','1','checked','on'].includes(s);
          }
          return false;
        } catch { return false; }
      };
      return {
        get: (scope) => {
          try {
            const v = pathExpr.split('.').reduce((o, k) => (o ? o[k] : undefined), scope);
            return isTrue(v) ? 'â˜‘' : 'â˜';
          } catch { return 'â˜'; }
        }
      };
    }

    // Fallback to dotted path (e.g., assessment.title)
    return {
      get: (scope) => {
        try { return t.split('.').reduce((o, k) => (o ? o[k] : undefined), scope) ?? ''; } catch { return ''; }
      }
    };
  }

  app.get('/assessments/:id/export.docx', (req, res) => {
    try {
      const { id } = req.params;
      const templateName = (req.query.template || 'report.docx').toString();
      const templatePath = path.resolve('/root/template', templateName);
      if (!fs.existsSync(templatePath)) {
        return res.status(404).json({ success:false, message:`Template not found: ${templateName}` });
      }

      const a = assessments.find(x => x.id === id);
      if (!a) return res.status(404).json({ success:false, message:'Assessment not found' });
      const tasks = tasksByAssessment[id] || [];
      const messages = messagesByAssessment[id] || [];
      const answers = (typeof answersByAssessment !== 'undefined' ? (answersByAssessment[id] || {}) : {});

      
      // Load JSON mapping file for tag -> data path resolution (ease future config)
      let mapping = {};
      try { mapping = JSON.parse(fs.readFileSync(path.resolve(__dirname, 'docx-mapping.json'), 'utf8')); } catch {}
      function deepGet(obj, pathExpr) {
        if (!pathExpr) return '';
        if (Array.isArray(pathExpr)) {
          return pathExpr.reduce((o,k)=> (o ? o[k] : undefined), obj);
        }
        // allow escaped dots for keys like 1.1 => use 1\.1 in mapping
        const SENT = '__DOCX_DOT__';
        const safe = String(pathExpr).replace(/\\\./g, SENT);
        const parts = safe.split('.').map(p => p.replace(new RegExp(SENT, 'g'), '.'));
        return parts.reduce((o,k)=> (o ? o[k] : undefined), obj);
      }
      const dataModel = { assessment: a, answers, tasks, messages };
      const groups = {};
      try {
        for (const g of Object.keys(mapping || {})) {
          groups[g] = {};
          const keys = mapping[g] || {};
          for (const k of Object.keys(keys)) {
            const val = deepGet(dataModel, keys[k]);
            groups[g][k] = (val == null ? '' : val);
          }
        }
      } catch {}
      const contact = groups['Contact'] || {};
// Normalize Contact date fields to "Mon DD, YYYY" format
      try {        const dateKeys = ['Date-of-Report', 'Assessment-Start', 'Assessment-End', 'Onsite-Dates'];        for (const dk of dateKeys) {          const sv = contact[dk];          if (sv && /^\d{4}-\d{2}-\d{2}/.test(String(sv))) {            contact[dk] = fmtDate(sv);          }        }      } catch {}

      const scope = 
{
        assessment: {
          id: a.id,
          title: a.title,
          framework: a.framework || '',
          col: a.col || '',
          created: fmtDate(a.created),
          startDate: fmtDate(a.startDate),
          dueIn: a.dueIn || '',
          description: a.description || ''
        },
        ...groups,
        Contact: contact,
        tasks: tasks.map(t => ({ name: t.name, status: t.status, due: t.due || '' })),
        messages: messages.map(m => ({ user: m.user, time: m.time, text: m.text })),
        generatedAt: fmtDate(new Date().toISOString())
      };

      const content = fs.readFileSync(templatePath, 'binary');
      const zip = new PizZip(content);
      const doc = new Docxtemplater(zip, { paragraphLoop: true, linebreaks: true, parser: customParser, delimiters: { start: "{{", end: "}}" } });
      doc.setData(scope);
      doc.render();
      const buf = doc.getZip().generate({ type: 'nodebuffer' });
      const safeTitle = String(a.title || 'Assessment').replace(/[^a-z0-9._-]+/gi, '_').slice(0,64);
      const fname = `${a.id}-${safeTitle}.docx`;
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
      res.setHeader('Content-Disposition', `attachment; filename="${fname}"`);
      return res.send(buf);
    } catch (e) {
      console.error('Export DOCX failed:', e);
      return res.status(500).json({ success:false, message:'Export failed' });
    }
  });
} catch (e) {
  console.warn('DOCX export not initialized:', e && e.message);
}


app.get('/assessments/:id/tasks', (req,res)=>{
  const list = tasksByAssessment[req.params.id] || []; res.json({ success:true, tasks:list });
});
app.post('/assessments/:id/tasks', (req,res)=>{
  const { name, status='In Progress', due='7 Days' } = req.body || {};
  if (!name) return res.status(400).json({ success:false, message:'name required' });
  const id = 'T-' + Math.random().toString(36).slice(2,8);
  const task = { id, name, status, due };
  tasksByAssessment[req.params.id] = tasksByAssessment[req.params.id] || [];
  tasksByAssessment[req.params.id].push(task);
  res.status(201).json({ success:true, task }); saveData(snapshot());
});
app.get('/assessments/:id/messages', (req,res)=>{
  const list = messagesByAssessment[req.params.id] || [];
  res.json({ success:true, messages:list });
});
app.post('/assessments/:id/messages', (req,res)=>{
  const { user='System', text='', parentId=null, sections=[], attachments=[], mentions=[] } = req.body || {};
  if (!text) return res.status(400).json({ success:false, message:'text required' });
  const msg = {
    id:'M-' + Math.random().toString(36).slice(2,8),
    user,
    time: new Date().toLocaleString('en-US', { hour12:false }),
    text,
    parentId: parentId || null,
    sections: Array.isArray(sections) ? sections.filter(Boolean) : [],
    attachments: Array.isArray(attachments) ? attachments.filter(Boolean) : [],
    mentions: Array.isArray(mentions) ? mentions.filter(Boolean) : [],
  };
  messagesByAssessment[req.params.id] = messagesByAssessment[req.params.id] || [];
  messagesByAssessment[req.params.id].push(msg);
  saveData(snapshot());
  res.status(201).json({ success:true, message: msg });
});

function currentSnapshot() {
  return { assessments, tasksByAssessment, messagesByAssessment, attachmentsByAssessment, users };
}

// Save to sqlite on boot

// Attachments (assessment-level) and per-section linking
// List assessment attachments
app.get('/assessments/:id/attachments', (req,res)=>{
  const list = attachmentsByAssessment[req.params.id] || [];
  res.json({ success:true, attachments:list });
});

// Delete an attachment (metadata and optional file)
app.delete('/assessments/:id/attachments/:attId', (req, res) => {
  const { id, attId } = req.params;
  const list = attachmentsByAssessment[id] || [];
  const idx = list.findIndex(a => a.id === attId);
  if (idx === -1) return res.status(404).json({ success:false, message:'Attachment not found' });
  const removed = list.splice(idx, 1)[0];
  attachmentsByAssessment[id] = list;
  try { if (removed && removed.path) { fs.unlinkSync(removed.path); } } catch {}
  saveData(snapshot());
  res.json({ success:true, removed });
});

// Metadata-only create (name/url)
app.post('/assessments/:id/attachments', (req, res) => {
  const { id } = req.params;
  const { name, url, size } = req.body || {};
  if (!name) return res.status(400).json({ success:false, message:'name required' });
  const att = {
    id: 'F-' + Math.random().toString(36).slice(2,8),
    name,
    created: new Date().toLocaleString('en-US', { hour12:false }),
    modified: new Date().toLocaleString('en-US', { hour12:false }),
    size: size || 'â€”',
    url: url || null,
  };
  attachmentsByAssessment[id] = attachmentsByAssessment[id] || [];
  attachmentsByAssessment[id].push(att);
  saveData(snapshot());
  res.status(201).json({ success:true, attachment: att });
});

// Binary upload (application/octet-stream) with ?filename= or x-filename header
const UPLOAD_DIR = path.join(__dirname, 'uploads');
app.use('/uploads', express.static(UPLOAD_DIR));
app.post('/assessments/:id/attachments/upload', express.raw({ type: 'application/octet-stream', limit: '50mb' }), (req, res) => {
  const { id } = req.params;
  const filename = (req.query.filename || req.headers['x-filename'] || '').toString();
  if (!filename || !req.body || !Buffer.isBuffer(req.body)) {
    return res.status(400).json({ success:false, message:'filename and binary body required' });
  }
  const safe = filename.replace(/[^a-zA-Z0-9._-]/g, '_');
  const dir = path.join(UPLOAD_DIR, id);
  try { fs.mkdirSync(dir, { recursive: true }); } catch {}
  const filePath = path.join(dir, safe);
  try { fs.writeFileSync(filePath, req.body); } catch (e) { return res.status(500).json({ success:false, message:'Failed to write file' }); }
  const att = {
    id: 'F-' + Math.random().toString(36).slice(2,8),
    name: safe,
    created: new Date().toLocaleString('en-US', { hour12:false }),
    modified: new Date().toLocaleString('en-US', { hour12:false }),
    size: `${req.body.length} bytes`,
    url: `/uploads/${id}/${encodeURIComponent(safe)}`,
    path: filePath,
  };
  attachmentsByAssessment[id] = attachmentsByAssessment[id] || [];
  attachmentsByAssessment[id].push(att);
  saveData(snapshot());
  res.status(201).json({ success:true, attachment: att });
});

// Section attachments - list resolved attachments for subsection
app.get('/assessments/:id/sections/:subId/attachments', (req, res) => {
  const { id, subId } = req.params;
  const refs = (sectionAttachmentsByAssessment[id] || {})[subId] || [];
  const all = attachmentsByAssessment[id] || [];
  const set = new Set(refs);
  const resolved = all.filter(a => set.has(a.id));
  res.json({ success:true, ids: refs, attachments: resolved });
});

// Link/unlink attachments to a subsection via patch { add?: string[], remove?: string[] }
app.put('/assessments/:id/sections/:subId/attachments', (req, res) => {
  const { id, subId } = req.params;
  const { add = [], remove = [] } = req.body || {};
  const current = sectionAttachmentsByAssessment[id] = sectionAttachmentsByAssessment[id] || {};
  const list = new Set(current[subId] || []);
  // validate adds exist
  const allIds = new Set((attachmentsByAssessment[id] || []).map(a => a.id));
  (Array.isArray(add) ? add : []).forEach(attId => { if (allIds.has(attId)) list.add(attId); });
  (Array.isArray(remove) ? remove : []).forEach(attId => list.delete(attId));
  current[subId] = Array.from(list);
  sectionAttachmentsByAssessment[id] = current;
  saveData(snapshot());
  const resolved = (attachmentsByAssessment[id] || []).filter(a => list.has(a.id));
  res.json({ success:true, ids: current[subId], attachments: resolved });
});

// Unlink one attachment id
app.delete('/assessments/:id/sections/:subId/attachments/:attId', (req, res) => {
  const { id, subId, attId } = req.params;
  const current = sectionAttachmentsByAssessment[id] = sectionAttachmentsByAssessment[id] || {};
  const list = new Set(current[subId] || []);
  const existed = list.delete(attId);
  current[subId] = Array.from(list);
  sectionAttachmentsByAssessment[id] = current;
  saveData(snapshot());
  res.json({ success:true, removed: existed ? attId : null, ids: current[subId] });
});
try { const sqlite = require('./db-sqlite'); if (sqlite && typeof sqlite.saveAll === 'function') { sqlite.saveAll(currentSnapshot()); } } catch (e) { console.warn('SQLite initial save skipped', e.message); }

// Start server
app.listen(3001, '0.0.0.0', () => {
  console.log('ðŸš€ FRESH Backend running on http://0.0.0.0:3001');
  console.log('ðŸ” Health: http://95.217.190.154:3001/health');
  console.log('ðŸ” Login: admin@acme.example.com / demo123!');
});

app.put('/assessments/:id', (req,res)=>{
  const { id } = req.params;
  const idx = assessments.findIndex(a => a.id === id);
  if (idx === -1) return res.status(404).json({ success:false, message:'Assessment not found' });
  const { title, col, dueIn, framework } = req.body || {};
  if (title !== undefined) assessments[idx].title = title;
  if (col !== undefined) assessments[idx].col = col;
  if (dueIn !== undefined) assessments[idx].dueIn = dueIn;
  if (framework !== undefined) assessments[idx].framework = framework;
  res.json({ success:true, assessment: assessments[idx] }); saveData(snapshot());
});

app.delete('/assessments/:id', (req,res)=>{
  const { id } = req.params;
  const idx = assessments.findIndex(a => a.id === id);
  if (idx === -1) return res.status(404).json({ success:false, message:'Assessment not found' });
  assessments[idx].archived = true;
  res.json({ success:true, assessment: assessments[idx] }); saveData(snapshot());
});

app.put('/assessments/:id/unarchive', (req,res)=>{
  const { id } = req.params;
  const idx = assessments.findIndex(a => a.id === id);
  if (idx === -1) return res.status(404).json({ success:false, message:'Assessment not found' });
  assessments[idx].archived = false;
  res.json({ success:true, assessment: assessments[idx] }); saveData(snapshot());
});

app.delete('/assessments/:id/messages/:msgId', (req,res)=>{
  const { id, msgId } = req.params;
  const list = messagesByAssessment[id] || [];
  const idx = list.findIndex(m => m.id === msgId);
  if (idx === -1) return res.status(404).json({ success:false, message:'Message not found' });
  const removed = list.splice(idx,1)[0];
  messagesByAssessment[id] = list;
  saveData(snapshot());
  res.json({ success:true, removed });
});

// --- Answers API (per-assessment, per-subsection form values) ---
// GET answers for an assessment
app.get('/assessments/:id/answers', (req, res) => {
  const { id } = req.params;
  const answers = answersByAssessment[id] || {};
  res.json({ success: true, answers });
});

// PUT answers patch: { [subsectionId]: { fieldId: value } }
app.put('/assessments/:id/answers', (req, res) => {
  const { id } = req.params;
  const patch = req.body || {};
  if (typeof patch !== 'object' || Array.isArray(patch)) {
    return res.status(400).json({ success: false, message: 'Invalid payload' });
  }
  const current = (answersByAssessment[id] = answersByAssessment[id] || {});
  for (const key of Object.keys(patch)) {
    const value = patch[key];
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      current[key] = { ...(current[key] || {}), ...value };
    } else {
      // if value is not an object, store raw value under a default field
      current[key] = value;
    }
  }
  answersByAssessment[id] = current;
  saveData(snapshot());
  res.json({ success: true, answers: current });
});
